https://www.youtube.com/watch?v=OGEezPl9Ixk
https://www.youtube.com/watch?v=2Xyp8NkPLrg
https://www.youtube.com/watch?v=qX-m1HjiXJg
https://www.intelligentciso.com/2025/03/11/confidential-computing-the-key-to-ai-security/#:~:text=In%20the%20context%20of%20AI,data%20and%20extract%20actionable%20insights.
https://www.youtube.com/watch?v=Ah5FGrmj81M
https://vanbulck.net/files/drads25-keynote.pdf
https://arxiv.org/abs/2503.08256
https://datatracker.ietf.org/meeting/122/materials/slides-122-hackathon-sessd-identity-crisis-for-attested-tls-in-confidential-computing-00
https://www.lfdecentralizedtrust.org/blog/lf-decentralized-trust-mentorship-spotlight-cc-tools-support-for-fabric-private-chaincode
https://medium.com/@wunderlichvalentin/the-end-of-just-trust-us-6141dbdaa07e
https://www.tenforums.com/tech-news/218632-amd-helping-secure-gpus-advance-ai.html
https://community.amd.com/t5/instinct-accelerators/helping-secure-gpus-that-advance-ai/ba-p/752288
https://www.youtube.com/watch?v=32K_v7hRgUQ
https://confidentialcomputing.io/2025/03/06/does-confidential-computing-work-with-containers/?utm_content=326800929&utm_medium=social&utm_source=twitter&hss_channel=tw-1276283047927840771
https://diginova1.gumroad.com/l/gokyd
https://www.tealhq.com/job/software-engineer-iii-privacy-sandbox-android-on-device-personalization_1c946893-fd11-4141-9584-92a55e4c477d?target_titles=android+software+engineer&page=14
https://arxiv.org/html/2502.11347v1
https://www.youtube.com/watch?v=MME6r3bqAtQ
https://blog.codepipes.com/testing/software-testing-antipatterns.html?utm_source=blog.quastor.org&utm_medium=newsletter&utm_campaign=how-uber-built-an-exabyte-scale-system-for-data-processing
https://aijobnetwork.com/jobs/openai-software-engineer-trusted-computing-and-cryptography
https://thomasvanlaere.com/
https://www.youtube.com/watch?v=OGEezPl9Ixk
https://news.ycombinator.com/item?id=42570988
https://xeiaso.net/blog/2025/squandered-holy-grail/
https://www.bedlamresear.ch/posts/securing-tee-apps/#the-allure-of-tees
https://vanishinggradients.fireside.fm/40
https://github.com/Azure/azure-cleanroom/tree/main
https://arxiv.org/pdf/2011.02455
https://orbstack.dev/
https://blog.1password.com/confidential-computing/#:~:text=Confidential%20computing%20is%20a%20new,to%20being%20accessed%20by%20others.
https://www.youtube.com/watch?v=QxArt51VQKA
https://medium.com/ultraviolet-blog/cube-ai-privacy-preserving-llm-applications-with-confidential-computing-dcddfd28c614
https://www.usenix.org/system/files/conference/hotcloud16/hotcloud16_burns.pdf
https://oasisprotocol.org/blog/verifiable-ai-with-tees
https://arxiv.org/pdf/2412.03842
https://encloud.tech/faqs/
https://www.youtube.com/watch?v=E91z2YenrZM
https://www.youtube.com/watch?v=XssGI1q7Jak
https://arxiv.org/pdf/2412.01059
https://arxiv.org/html/2412.03842v3
https://www.youtube.com/watch?v=zc90pWZ7vj0
https://arxiv.org/html/2412.13163v1
https://www.ietf.org/id/draft-ietf-teep-usecase-for-cc-in-network-08.html#:~:text=Abstract,process%20data%20in%20that%20environment.
https://github.com/bpradipt/awesome-confidential-computing
https://github.com/openenclave/openenclave/issues/4845
https://insights.sei.cmu.edu/documents/4388/2021_017_001_739363.pdf
https://github.com/hysnsec/awesome-policy-as-code?tab=readme-ov-file
https://www.dropbox.com/scl/fi/3typ46aqn6h7yo6s0war7/L3-Intro-to-Crypto-Digital-Sig.pdf?rlkey=oxl1m5sg7dwlsmew02dtih5bc&e=1&dl=0
https://techcommunity.microsoft.com/blog/azureconfidentialcomputingblog/announcing-azure-confidential-vms-with-nvidia-h100-tensor-core-gpus-in-preview/3975389
https://arxiv.org/pdf/2403.10296
https://dzone.com/articles/aws-nitro-enclaves-enhances-security
https://dse.in.tum.de/wp-content/uploads/2024/11/sigmetrics25summer-CVM-Explained.pdf
https://www.youtube.com/watch?v=NT7EsZ6HRus
https://arxiv.org/html/2412.13163v2
https://systex22.github.io/papers/systex22-final79.pdf
https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/acrobat-17.pdf
file:///C:/Users/Khalil/Downloads/Marc%20Boorshtein,%20Scott%20Surovich%20-%20Kubernetes%20%E2%80%93%20An%20Enterprise%20Guide_%20Effectively%20containerize%20applications,%20integrate%20enterprise%20systems,%20and%20scale%20applications%20in%20your%20enterprise,%202nd%20Edition-Packt%20Pu.pdf
https://techcommunity.microsoft.com/blog/azureconfidentialcomputingblog/azure-ai-confidential-inferencing-technical-deep-dive/4253150
https://www.youtube.com/watch?v=53kf4LY5YdM
https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/acrobat-17.pdf
https://www.youtube.com/watch?v=jwYrTBbrOfk
https://www.reddit.com/r/apple/comments/1d3evub/apples_artificial_intelligence_servers_will_use/
https://play.google.com/books/reader?id=rqspEQAAQBAJ&pg=GBS.PT135.w.2.0.39.0.1_144&hl=en
https://confidentialcontainers.org/
https://learn.microsoft.com/en-us/azure/confidential-computing/confidential-clean-rooms
https://www.youtube.com/watch?v=QNX5JfV390c&list=PLBexUsYDijaz09nH8BVPmPio_16V115i4&index=37
https://podcast.aiconfidential.com/?utm_source=aiconfidential.com&utm_medium=newsletter&utm_campaign=the-mathematical-case-for-trusted-ai-why-anthropic-is-all-in-on-confidential-computing
https://techcommunity.microsoft.com/category/azure/blog/azureconfidentialcomputingblog
https://hwang595.github.io/publications/
https://chungkim.io/
https://people.csail.mit.edu/mengyuanli/
https://books.google.com/books/about/Introduction_to_Confidential_Computing.html?id=rqspEQAAQBAJ
https://arxiv.org/html/2407.02960v2
https://www.youtube.com/playlist?list=PLBexUsYDijaz14Mot8_6rAbxkoF4iS6PZ
https://www.youtube.com/playlist?list=PLOspHqNVtKABAVX4azqPIu6UfsPzSu2YN
https://www.youtube.com/watch?v=_IAfiSdPuEs
https://www.youtube.com/watch?v=BgrQ16r84pM&list=PLBexUsYDijaz14Mot8_6rAbxkoF4iS6PZ&index=3
https://www.youtube.com/playlist?list=PLOspHqNVtKAC-_ZAGresP-i0okHe5FjcJ
https://www.youtube.com/watch?v=0ctat6RBrFo&list=PLOspHqNVtKACfjqfEwR3iKz1gJILKj5Tn&index=8
https://www.youtube.com/watch?v=pMHxLBJ6_UA&list=PLOspHqNVtKACfjqfEwR3iKz1gJILKj5Tn&index=24
https://www.youtube.com/playlist?list=PLOspHqNVtKADX-InvL3aRFYuOYvi-Qmep
https://www.youtube.com/watch?v=DqdVjEe5f6o
https://www.reddit.com/r/Proxmox/comments/1i940p0/what_is_the_point_of_amdsev/
https://www.youtube.com/watch?v=WpTUWaXWTQE
https://www.youtube.com/watch?v=SCHYdDaExrI
https://arxiv.org/pdf/2501.11558
https://www.nature.com/research-intelligence/trusted-execution-environments-and-security-architectures
https://research.google/blog/parfait-enabling-private-ai-with-research-tools/
https://www.youtube.com/watch?v=ytifTS9Lrn0
https://fosdem.org/2025/events/attachments/fosdem-2025-5002-confidential-computing-s-recent-past-emerging-present-and-long-lasting-future/slides/236697/Confident_fRySvCW.pdf

Several software-based storage system protection techniques are integrated into mainstream operating systems. Encryption-enabled file systems (e.g., Linux ecryptfs [37], and Windows EFS [1]) allow directory-level encryption. Block-layer encryption techniques such as dmcrypt [25] directly encrypt the entire block device. dm-crypt also offers integrity checking of read-only filesystems where the entire block device is verified at once. This approach is particularly time-consuming and thus is typically used only during device startup [6], [44]. dm-verify [6] uses a software maintained Merkle tree structure to compute and validate hashes of read-only data blocks against pre-computed hashes. In contrast, dm-integrity keeps individual hashes for each data block during runtime, which allows verification for read/write system. However, it cannot detect physical attacks such as reordering the blocks within the same device due to the lack of a secure root of trust in the system. Finally, software-based schemes can have substantial overhead as the en/decryption is done in software via executing many kernel sub-routines across software layers [15], [63].

* Trivy
* Container image vulnerabiltiy management
* Code coverage
* OIDC
* PKI, Public Key, Private Key

### Links
* https://redhat-crypto.gitlab.io/defensive-coding-guide/#chap-Defensive_Coding-TLS

### Shell Programming and Bash
1. Print Call Stack: Use trap DEBUG and Bash variables like ${FUNCNAME[@]}, ${BASH_SOURCE[@]}, and ${BASH_LINENO[@]} to trace function calls, making debugging easier.
2. getopts: Parse command-line flags robustly and maintainably, avoiding manual parsing pitfalls.
3. wait: Control concurrency by running multiple tasks in the background and waiting for them to finish, ensuring correct sequencing.
4. co-process: Interact with a background command via built-in pipes (file descriptors), enabling bidirectional communication in real time.

### Network Security
* Ensure the server presents a TLS certificate that is valid according to the public key infrastructure (PKI) used by web browsers (e.g., certificates signed by trusted Certificate Authorities). For example, a website served over HTTPS (e.g., https://example.com) has a TLS certificate signed by a recognized CA (like Let’s Encrypt). When a user visits the site, the browser verifies the certificate, confirming that the server is indeed example.com.
* Have the client validate the server’s TLS certificate against a known or expected certificate. In this case, you do not need to do host name checking (the certificate identity is already trusted). A mobile app might pin the server’s TLS certificate. The app includes the certificate or its fingerprint in its configuration. When connecting, the app compares the server’s certificate with the pinned fingerprint. If they match, the app trusts the connection; if not, it refuses to connect.
* On Linux, use UNIX domain sockets (of the PF_UNIX protocol family). These sockets can be protected by file system permissions (ownership and mode bits), preventing unauthorized processes from binding to them. For example, a backend microservice listens on /var/run/myservice.sock. The file system permissions are set to owner: myuser and mode: 0700. This means only myuser (and processes running under it) can write to or bind that socket, reducing the chance of impersonation.
* Always use TLS when connecting over untrusted or public networks to secure the communication channel and protect against eavesdropping or tampering. For example, your application communicates with a remote server over the internet. You enable TLS (e.g., HTTPS or TLS for mail protocols like SMTPS/IMAPS) to encrypt all data in transit, ensuring that attackers on public Wi-Fi or other untrusted networks cannot easily spy on or modify the data.
* Port numbers below 1024 (often called “trusted ports”) can only be used by the root user on some operating systems. This restriction helps ensure that only privileged processes can bind to those ports. For example, a web server runs on port 443 for HTTPS. Since 443 is under 1024, only a root-privileged process (or one that started as root) can bind to it. This makes it harder for a malicious local user to set up a fake server on port 443.
* If the server runs on a port number ≥ 1024, a non-root (local) user could potentially impersonate the server process by binding to the same port—especially after forcing the real server to crash or otherwise stop. For example, a service listening on port 8080 (≥ 1024) is forcibly shut down by an attacker (via DoS). The attacker then starts a malicious process bound to port 8080. Since 8080 is not privileged, the attacker’s fake server might intercept legitimate client requests.
* Most TLS libraries enable insecure or obsolete cipher suites by default (e.g., anonymous Diffie-Hellman, export ciphers). You should use a whitelist of strong cipher suites rather than selectively disabling undesirable ones.

### Working in a Team
* How much time is each team member expected to be putting into working on the project?
* How will you deal with unforeseen circumstances affecting team members (e.g. sickness, interviews, competitions)?
* How will team members be kept accountable for their contributions?
* When will your team meet? Setting aside a day and time for recurring meetings is a big marker of team success.
* What platform(s) will your team be using to communicate? How quickly should team members respond?
* Will you meet in person or via Zoom? What are the expectations or non-negotiables for these meetings?
* If a deadline is approaching and tasks remain incomplete, how will you convene and communicate to ensure completion?
* How will responsibilities and tasks be divided among team members?
* Who will be responsible for organizing, facilitating, and taking notes during meetings? How will this responsibility rotate?
* How will the team address any issues related to teamwork that may arise?
* What steps will the team take if a member is contributing too little, and at what point will this issue be escalated to the instructors?

### Types of People in a Project
* Contributor: Aim for general team success, discuss solutions with your team. Ask for their opinion and demonstrate engagement during the activity.
* Know-it-all: You think you are extremely experienced and know how to solve the problem on your own. Act like you do not need help and just tell your team to watch while you search for the tool. Try to tell other members how to search for information about the tool. Be combative and shoot another member’s idea down if possible.
* Act silent: Pay attention to the meeting, but simply do not suggest anything. You assume your team members know everything and don’t feel you need to say much. Remain passive but friendly.
* Agree with everything: Do not question the decisions of your team. You are afraid of raising conflicts; so just agree with everything during the activity.
* Hitchhiking: Your goal is to do as little work as possible. Be friendly but not productive. Try to get other people to step in for you, for example you can act confused with the task and say that you need someone else to do this for you. You may have to make a quick, bad attempt to make it look like you tried to figure out the task.
* Commitment issue: Go along with the meeting, until when tasks are being assigned, say that you are busy with something (interview prep, midterm, other assignment). If asked if they could do something else, or if being pressed further continue giving excuses why you can’t contribute.
* Perfectionist: You will perfect even minor details. Your role is to make sure the tool’s source code is readable and aesthetically perfect and that also includes perfect comments. You should argue for or against the tool based on these minor details.

### Linux Tools
#### Helpful Utilities & Tools
1. `watch`: re-runs a command at fixed intervals, updating the display each time.
2. `time`: measures how long a command or script takes to run. with `/usr/bin/time -v`, can get max memory usage, page faults, etc.
3. `tee`: splits the output stream, saving it to a file while still displaying it on stdout.
4. `tmux`: terminal multiplexer, allowing multiple “windows” and “panes” within a single terminal session. keep commands running on a remote server even if you disconnect. multiple users can attach to the same tmux session for pair programming or debugging
5. `cron`: time-based job scheduler. can be used for automating backups/cleanups/log rotation, collecting metrics, or generating reports
6. `entr` or `watchexec`: interactively re-run commands on file change. can be used to automatically recompile on save.

#### Debugging & Tracing
1. `gdb`: The GNU Debugger for compiled languages (C, C++, Rust, etc.).
2. `ltrace`: traces library calls (e.g., glibc calls) made by a process.
3. `strace`: traces system calls (open, read, write, socket, etc.) and signals.
4. `lsof`: lists open files and the processes that opened them.
5. `eBPF`: lets you safely run tiny programs inside the Linux kernel, without modifying or rebooting it. used to observe and control low-level system behavior—like tracing kernel functions, filtering or modifying network traffic, and collecting custom metrics. 
6. `journalctl`: reads logs managed by systemd.
7. `systemctl`: manages systemd services (start, stop, enable, disable).

#### System Information
1. `ps aux`: shows all running processes with CPU/memory usage.
2. `free`: shows free and used memory, including swap usage.
3. `df`: check disk space usage on mounted filesystems.
4. `lsusb`: lists USB devices connected to the system.
5. `lspci`: shows PCI devices on the system (graphics cards, network controllers, etc.).
6. `lshw`: lists comprehensive hardware info—CPU, memory, disks, network, etc.
7. `lscpu`: detailed CPU architecture information

#### Performance & Resource Monitoring
1. `perf`: profiler. can use it to identify which functions consume the most CPU time or how time is spent in user-space or kernel-space by analyzing events like context switches, cache misses, etc.
2. `top`: see CPU usage, memory usage, and which processes are hogging resources.
3. `iotop`: top-like interface for disk I/O. 
4. `flameGraph`: visualize stack traces as a flame graph. can use it to identify "hot" functions or loops in your program.
5. `vmstat`: reports processes, memory, paging, block I/O, traps, and CPU activity.
6. `iostat`: reports CPU and I/O usage of devices, partitions, and NFS.
7. `dstat`: combines `vmstat`, `iostat`, `netstat`, `ifstat` for a comprehensive, real-time resource usage view.
8. `sar`: continuously collects data, letting you investigate performance at a specific time in the past.

#### Filesystem Management
1. `fdisk` / `parted`: manages disk partitions
2. `mount/umount`: attach/detach filesystems (USB drives, NFS shares, partitions).

### aaa
Continuous Integration (CI) refers to the practice of automatically building and testing the codebase whenever new changes are introduced. This involves integrating code changes from multiple developers into a shared repository and running automated tests to ensure that the changes do not break the existing functionality.

Continuous Deployment/Delivery (CD) refers to the practice of automatically deploying code changes to the production environment after they have been tested and approved. Continuous Deployment involves automatically deploying changes to the production environment as soon as they pass automated tests, while Continuous Delivery involves deploying changes to a staging environment for further testing and approval before being deployed to production.

Together, CI/CD enables software teams to rapidly and safely develop, test, and deploy changes to the codebase, improving the speed and quality of software delivery while reducing the risk of errors and downtime.

### b
